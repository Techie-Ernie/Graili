<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FastAPI + Puter.js Test</title>
    <script src="https://js.puter.com/v2/"></script>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 50px auto; padding: 20px; }
        button { padding: 10px 20px; margin: 5px; cursor: pointer; }
        .output { background: #f4f4f4; padding: 15px; margin: 10px 0; border-radius: 5px; white-space: pre-wrap; }
        .success { color: green; }
        .error { color: red; }
        h1 { color: #333; }
    </style>
</head>
<body>
    <h1>Graili (Grail Improved) </h1>
    
    <h2>1. Test Backend Connection</h2>
    <button onclick="testConnection()">Test FastAPI Connection</button>
    <div id="connectionResult" class="output"></div>
    
    <h2>2. Get Data from Backend</h2>
    <button onclick="getData()">Fetch Data</button>
    <div id="dataResult" class="output"></div>
    
    <h2>3. Run AI Pipeline with Puter.js</h2>
    <button onclick="runPipeline()">Run Full Pipeline</button>
    <div id="pipelineResult" class="output"></div>

    <script>
        const API_URL = "http://localhost:8000";

        async function testConnection() {
            const resultDiv = document.getElementById("connectionResult");
            resultDiv.innerHTML = "Testing...";
            try {
                const res = await fetch(`${API_URL}/test`);
                const data = await res.json();
                resultDiv.innerHTML = `<span class="success">✓ Connected!</span>\n${JSON.stringify(data, null, 2)}`;
            } catch (err) {
                resultDiv.innerHTML = `<span class="error">✗ Error: ${err.message}</span>`;
            }
        }

        async function getData() {
            const resultDiv = document.getElementById("dataResult");
            resultDiv.innerHTML = "Fetching...";
            try {
                const res = await fetch(`${API_URL}/data`);
                const data = await res.json();
                resultDiv.innerHTML = `<span class="success">✓ Data received:</span>\n${JSON.stringify(data, null, 2)}`;
            } catch (err) {
                resultDiv.innerHTML = `<span class="error">✗ Error: ${err.message}</span>`;
            }
        }

        async function runPipeline() {
            const resultDiv = document.getElementById("pipelineResult");
            resultDiv.innerHTML = "Running pipeline...\n";
            
            try {
                // 1. Get scraped data from backend
                resultDiv.innerHTML += "\n1. Fetching data from backend...";
                const dataRes = await fetch(`${API_URL}/data`);
                const { text } = await dataRes.json();
                resultDiv.innerHTML += `\n   ✓ Got text: "${text.substring(0, 50)}..."`;
                model = "gemini-2.5-flash-lite"
                // 2. Run Puter AI
                resultDiv.innerHTML += `\n\n2. Sending to ${model} ...`;
                
                let output;
                try {
                    const prompt = 
                    `
                    You are an information extraction engine. You MUST NOT generate any content that is not present verbatim in the input.

                    TASK
                    Extract ONLY the actual exam sub-questions from the given paper text (ignore instructions, headers, source lines, extracts, figures, totals, and any non-question content). Classify each extracted sub-question into:
                    - "exam": sub-questions that have an explicit mark allocation in square brackets, attached per rules below
                    - "understanding": sub-questions that do NOT have an explicit mark allocation attached per rules below

                    CRITICAL: NO HALLUCINATIONS
                    - Output ONLY questions that appear verbatim in the input text.
                    - DO NOT paraphrase, summarize, or invent any questions.
                    - DO NOT create “understanding” questions unless they are verbatim in the input.
                    - If there are no understanding questions, "understanding" MUST be [].

                    DEFINITION OF QUESTION
                    A “question” is a line/block that asks the candidate to do something (e.g., Explain/Discuss/Describe/Analyse/Compare/Evaluate/With reference to..., etc.), including subparts like (a), (b), (c)(i), (ii), etc.

                    EXCLUSIONS (NOT QUESTIONS)
                    Do NOT extract:
                    - General instructions (e.g., “Answer all questions”, “You are required to answer…”)
                    - Section instructions (e.g., “One or two of your three chosen questions…”)
                    - Totals lines like “[Total: 30]”
                    - Any bracketed text that is NOT a mark allocation (e.g., quotes like “free trade [but] ...”)
                    - Source citations and headers

                    MARK ASSOCIATION RULE (STRICT + MECHANICAL)
                    A sub-question has marks ONLY if there is a square-bracketed integer mark like [2], [4], [8], [10], [15] that is:
                    1) On the same line as the sub-question, OR
                    2) On the immediately following NON-EMPTY line (after trimming whitespace).

                    A square-bracketed value is NOT a mark allocation if it matches:
                    - [Total: ...] (case-insensitive)
                    - any bracketed word/phrase containing letters (e.g., [but], [Total], [Source])
                    Only pure integers inside brackets count as marks: [number]

                    If a pure-integer mark is found by rule (1) or (2), append it to the end of the question text separated by a single space, exactly as written (e.g., "... [10]").
                    If no such mark is attached, DO NOT add any brackets.

                    THEME & SUBTHEME MAPPING (STRICT)

                    - You MUST assign a syllabus chapter AND subchapter number (e.g. 2.2.2) to EVERY extracted question.
                    - Do NOT output "Unknown".
                    - Do NOT skip chapter assignment.
                    - Use the MOST SPECIFIC applicable subchapter number from the syllabus.

                    Theme format MUST be:
                    "<syllabus_number> <syllabus_chapter_title>"

                    Examples:
                    - "2.2.2 Inflation and its causes"
                    - "1.3.1 Price controls"
                    - "3.1.4 Trade protectionism"


                    OUTPUT FORMAT (STRICT JSON ONLY)
                    Return JSON ONLY in this exact structure:
                    {
                    "exam": [
                        { "chapter": "<chapter>", "question": "<verbatim question text with attached mark if present>", "marks": <number of marks allocated>}
                    ],
                    "understanding": [
                        { "chapter": "<chapter>", "question": "<verbatim question text with NO marks>" }
                    ]
                    }

                    FINAL VALIDATION (MANDATORY, DO NOT OUTPUT)
                    - Every "exam" question MUST end with a pure-integer bracket mark like [10].
                    - No "understanding" question may contain '[' or ']'.
                    - Do not output any item that is not verbatim from the input.

                    SYLLABUS + TEXT:

                    `+
                    text;
                    const aiResponse = await puter.ai.chat(prompt, {
                        model: model
                    });
                    
                    // Handle different response formats
                    if (typeof aiResponse === 'string') {
                        output = aiResponse;
                    } else if (aiResponse?.message?.content) {
                        output = aiResponse.message.content;
                    } else if (aiResponse?.content) {
                        output = aiResponse.content;
                    } else {
                        output = JSON.stringify(aiResponse);
                    }
                } catch (aiErr) {
                    resultDiv.innerHTML += `\n Error: ${aiErr.message || aiErr}`;
                    console.error("Puter AI error:", aiErr);
                    return;
                }

                resultDiv.innerHTML += `\n  Response "${output}"`;
                resultDiv.innerHTML += "\n\n3. Sending AI result to backend...";
                let resultObj;
                try {
                    const cleaned = output.replace(/```json|```/g, "").trim();
                    resultObj = JSON.parse(cleaned);
                } catch (e) {
                    throw new Error("AI output is not valid JSON");
                }
                const postRes = await fetch(`${API_URL}/ai-result`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    
                    body: JSON.stringify({
                        "result": resultObj,
                        "context": {
                            "year": 2023,
                            "subject": "Economics",
                            "category": "A-Level",
                            "question_type": "exam",
                            "source": "Holy Grail PDF"  
                        }
                    })
                });
                
                const postData = await postRes.json();
                resultDiv.innerHTML += `\n   ✓ Backend response: ${JSON.stringify(postData)}`;

                resultDiv.innerHTML += `\n\n<span class="success">✓ Pipeline completed successfully!</span>`;
            } catch (err) {
                resultDiv.innerHTML += `\n\n<span class="error">✗ Pipeline error: ${err.message || err}</span>`;
                console.error("Pipeline error:", err);
            }
        }
    </script>
</body>
</html>
